---
title: 剑指offer 11. 旋转数组的最小数字
date: 2020-07-25 17:05:58
tags:
---

# 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

<!--more-->

示例 1：
```
输入：[3,4,5,1,2]
输出：1
```

示例 2：
```
输入：[2,2,2,0,1]
输出：0
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

难度：简单

标签：二分查找

# 我的解答

## 遍历

最开始我没有想到二分法，直接用的遍历的方式。

无论是遍历还是二分法，这里有个细节值得注意：以遍历为例，直接地会想到两种方法——从前向后编列和从后向前遍历。  
从前向后遍历找比前一个位置元素小的；  
从后向前遍历找比后一个位置元素大的。

直觉上好像没有太大的差异，但其实从前向后遍历是不完善的，因为没有考虑数组可能本身就是非递减的数组，即并没有任何旋转。

```java
// Java
class Solution {
    public int minArray(int[] numbers) {
        for (int i = numbers.length - 1; i >= 1; --i) {
            if (numbers[i - 1] > numbers[i]) {
                return numbers[i];
            }
        }

        return numbers[0];
    }
}
```

从前向后遍历虽不完善，但是仍有改进空间，即事先判断旋转数组的首尾元素大小：
- 若首 < 尾，则首元素就是旋转点
- 否则从左到右遍历，仍可找到旋转点

这两种遍历方式的区别在文章后续提到的二分法中仍有类似体现和解决方法。

# 优秀题解

## 二分

参考了[优秀题解]。

**有序数组的问题要首先要考虑二分**。二分可以将原本线性级别的时间复杂度降低至对数级别。

通过思考不难发现旋转数组的一些性质：
1. 我们可以将旋转后的数组看作2个部分，即**左排序数组**和**右排序数组**
2. 左排序数组一定不为空，右排序数组可能为空
3. 左排序数组和右排序数组分别为**非递减数组**
4. 左排序数组的第一个元素（即最小元素）**大于或等于**右排序数组的最后一个元素（即最大元素）
5. 若右排序数组不为空，所求的旋转点为右排序数组的第一个元素，否则旋转点为左排序数组的第一个元素，即旋转数组的第一个元素。

```
    ^ |
  ^ ^ |
^ ^ ^ |     ^
^ ^ ^ |   ^ ^
^ ^ ^ | ^ ^ ^
 左   | 右
```

利用这些性质，我们用`i`和`j`分别指向整个旋转数组`numbers`的头尾，用`m = (i + j) / 2`指向二分的中点，分类讨论后有以下几种情况：

```
    ^ |
  ^ ^ |
^ ^ ^ |     ^
^ ^ ^ |   ^ ^
^ ^ ^ | ^ ^ ^
i     |     j
```
- `numbers[i] < numbers[j]`。此时说明右排序数组为空，根据性质5，直接返回`numbers[i]`
- 否则
  - `numbers[m] > numbers[j]`。此时说明`m`指向了左排序数组中的某个位置，因为根据性质3和性质4可得右排序数组不为空，`j`指向了右排序数组中最大的元素，如果`m`指向的元素比`j`指向的元素还大，那么`m`一定在左排序数组中，那么根据性质5，旋转点`target`一定处于`[m + 1, j]`的范围中。此时令`i = m + 1`，准备下一次二分
  - `numbers[m] < numbers[j]`。此时还需分2类进行讨论
    - 若右排序数组不为空。此时说明`m`指向了右排序数组中的某个位置，因为根据性质3和性质4，比`j`指向的元素还小的元素，只可能在右排序数组中。旋转点`target`一定处于`[i, m]`的范围中（`m`可能就指向了`target`）。此时令`j = m`，准备下一次二分
    - 若右排序数组为空。那么`target`元素就位于左排序数组的第一个元素，同样满足*旋转点`target`一定处于`[i, m]`的范围中*。此时仍可令`j = m`，准备下一次二分
    - 综上，无论那种情况，都可以采取同样的策略
  - `numbers[m] == numbers[j]`。此时无法判断`m`究竟在左右哪个排序数组中，但可以确定的是：
    - 若`m`在右排序数组中，根据性质3可得，`[m, j]`区间内所有元素都相等，旋转点在`[i, m]`中
    - 若`m`在左排序数组中，根据性质3和性质4可得，`numbers[j] <= numbers[i, ..., m-1] <= numbers[m]`，同时`numbers[m] == numbers[j]`，则`numbers[j] == numbers[i, ..., m-1] == numbers[m]`，旋转点在`[m + 1, j]`中
    - 这样似乎并没有解决问题，但只要我们采取的操作能保证不丢失`target`的位置且`i`和`j`的值能产生变化即可
    - 进一步分析，因为`target`指向的元素是旋转数组中最小的元素，那么`numbers[target] <= numbers[m] == numbers[j]`，这里可进一步分为2种情况
      - 若`numbers[target] == numbers[m] == numbers[j]`
        - 若`m`在右排序数组中，则右排序数组内所有元素都相等，此时`j`可以不断减一，使得之后`m`可落在左排序数组中
        - 若`m`在左排序数组中，则`[i, m]`和右排序数组内的所有元素都相等，此时`j`也可以不断减一，直到退化到`j`落入左排序数组。这样最终返回的元素位置虽不是`target`，但其值与`numbers[target]`相同
      - 若`numbers[target] < numbers[m] == numbers[j]`
        - 若`m`在右排序数组中，`j`不断减一仍满足条件
        - 若`m`在左排序数组中，`j`不断减一仍可退化到`j`落入左排序数组。这样最终返回的元素位置虽不是`target`，但其值与`numbers[target]`相同
    - 所以此时可以采取的操作是`j = j - 1`。当然，这可能并非唯一正确的操作，
  - 最后，当`i == j`时跳出循环，并返回`numbers[i]`

与之前的遍历法一样，如果不事先判断右排序数组是否为空，不能选择`numbers[i]`作为比较对象，因为：
- 若`numbers[m] > numbers[i]`。此时说明`m`指向了左排序数组的某个位置，因为根据性质2和性质3，比`i`指向的位置大的元素只可能在左排序数组中，但仅此并不能证明右排序数组不为空，不能判断旋转点究竟是左排序数组的第一个元素还是右排序数组的第一个元素。为了证明右排序数组是否为空，则还需令`numbers[m]`和`numbers[j]`进行一次比较

但若先行根据`numbers[i]`和`numbers[j]`的大小关系判断出右排序数组存在性，就可以用`numbers[i]`作为比较对象。

```java
// Java
class Solution {
    public int minArray(int[] numbers) {

        int i = 0;
        int j = numbers.length - 1;
        int m = i + (j - i) / 2;

        if (numbers[i] >= numbers[j]) {
            while (i != j) {
                if (numbers[m] < numbers[j]) {
                    j = m;
                } else if (numbers[m] > numbers[j]) {
                    i = m + 1;
                } else {
                    --j;
                }
                m = i + (j - i) / 2;
            }
        }
        return numbers[i];
    }
}
```

[优秀题解]: https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/