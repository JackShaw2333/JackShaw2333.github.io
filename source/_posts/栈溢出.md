---
title: 栈溢出
date: 2020-07-20 13:47:32
tags:
---

# 什么是栈溢出？

以下是来自维基百科的定义。

<!--more-->

> In software, a stack overflow occurs if the call stack pointer exceeds the stack bound. The call stack may consist of a limited amount of address space, often determined at the start of the program. The size of the call stack depends on many factors, including the programming language, machine architecture, multi-threading, and amount of available memory. When a program attempts to use more space than is available on the call stack (that is, when it attempts to access memory beyond the call stack's bounds, which is essentially a buffer overflow), the stack is said to overflow, typically resulting in a program crash. 
> 
> 在软件中，如果调用栈的栈指针超出了栈的边界，则发生了栈溢出。调用栈由有限的地址空间组成，通常是在程序开始时确定。调用栈的大小取决于许多因素，包括具体的编程语言、机器架构、多线程以及可用的内存空间大小。当一个程序试图使用超出调用栈能够提供的更大的空间时（也就是说，当程序试图寻址的内存的地址超出了调用栈的边界，产生了缓冲区溢出），那么这个栈就发生了溢出，典型情况下会导致程序崩溃。
> 
>  ——[维基百科\[1\]](#参考资料)

本文部分结构编排参考了文章[内存布局与栈溢出&堆溢出原理][2][\[2\]](#参考资料)

# 内存布局

要讨论栈溢出，需要对内存布局有一定了解。

内存布局主要有2种，分为**系统内存空间**和**进程内存空间**。

以32位x86系统布局为例，32位操作系统可寻址的空间为2^32，也就是4G，所以每个进程最大的地址空间为4G。操作系统为了保证内核的安全，将虚拟的地址空间划分为2个部分，也就是**内核空间**和**用户空间**。
```
    +---------------+ <- 0xffffffff
    | 内核空间      |
    | Kernel Space  |   
    | 1GB           |
    +---------------+ <- 0xc0000000
    +---------------+ <- 0xbfffffff
    | 用户空间      |
    | User Space    |
    | 3GB           |
    +---------------+ <- 0x00000000  
```
一般的画法高地址在上，低地址在下。

高地址的1GB为系统内核空间，用户程序无权访问；下面3GB为用户内存空间，大小为3GB，这一部分内存供进程使用。这意味着最高1G的内核空间是**被所有进程共享**。

## 用户内存空间

用户内存空间也称为进程内存空间，主要由以下部分组成：

- stack：栈，高地址向低地址生长，用于**存储局部变量和函数参数值**，由操作系统自动分配。
- memory mapping segment：内存映射段，常用于**链接一些共享连接库**等。
- heap：堆，低地址向高地址生长，用于储存用户使用的`malloc`、`new`等函数或关键字所开辟的单元，其生命周期由垃圾回收算法决定。
- bss segment：bss段，存储一些**未初始化的全局变量/静态变量**或**赋值为0的全局变量/静态变量**。
- data segment：数据段，存储一些**已初始化的全局变量/静态变量**。
- text segment：文本段，存储**可执行文件的二进制映像，属性只读**。

```
+-------------------+ <- 0xbfffffff
|       stack       |
|         |         |
|         |         |
|         v         |
|       .....       |
+-------------------+
|   memory mapping  |
+-------------------+
|       .....       |
|         ^         |
|         |         |
|         |         |
|        heap       |
+-------------------+
|       .bss        |
+-------------------+
|       .data       |
+-------------------+
|       .text       |
+-------------------+
|       .....       |
|       .....       |
+-------------------+ <- 0x00000000
```

这些段之间会有一些空白部分，它们是一些任意的偏移量，由`ASLR地址空间随机化技术`（`ASLR地址空间随机化技术`是将进程的某些内存空间的地址进行随机化来预防缓冲区溢出攻击）实现。

## 虚拟内存

前面提到，对于每个进程来说，最大的地址空间为4G，但实际上并不可能为每个进程都分配4G的物理内存，为了实现这一点，涉及2个重要的概念（**虚拟页表**和**地址转换**）以及一个重要的部件（MMU）。

操作系统为每个进程分配的虚拟内存空间在进程看来是连续的，实际这一段虚拟内存有一部分在物理内存中，有一部分在外部的磁盘存储器上，所以当程序需要访问某个地址的数据时，需要进行一次地址转换的工作，这个工作由MMU（Memory Management Unit）完成。

```
    +---------+
    |   CPU   |
    +---------+          +---------+
    |   MMU   |          |  存储器  |
    +---------+          +---------+
         |                    ^
      物理地址                |
         |                    |
         v                    |
=============================================  总线
```

为了方便转换的过程，虚拟页表应运而生。虚拟页表将虚拟内存中的地址映射到物理内存中，当内存中没有某个虚拟地址对应的页框时，发生`缺页异常`，CPU从磁盘存储器中调页。

需要注意的是，进程中的某些段如`.data`和`.text`并非在进程运行时就全部加载到内存中，而只是建立进程的虚拟页表，当需要此数据并发送`缺页异常`时，才会将相应的内容放入内存。

# 栈溢出

栈的大小由编译器指定，也可以认为进行指定。

栈溢出最常见的情况是大量的递归导致的栈溢出。由于函数的每次递归都需要将函数的局部数据（局部变量、参数等）放入栈中，而栈的大小是有限的，大量的含有许多局部数据的递归将耗费大量的栈空间以致栈空间耗尽导致溢出。

**过多的递归调用**和**过大过多的局部参数**是导致栈溢出的两大原因。同时**指针或数组越界**也是非常重要的原因，由此也衍生出攻击计算机系统的方法，即`栈溢出攻击`，属于`缓冲区溢出攻击`的一种。

栈溢出攻击利用了代码中的漏洞，主要是没有检查输入的长度。攻击者将不合法的含有恶意的过长信息输入到程序中，由于程序检查输入长度，过长的输入信息将导致越界，并覆盖掉比该变量地址高的数据，以此达到篡改进程调用栈数据的目的。

## 栈工作原理

栈是一种具有先进后出特点的数据结构，这与函数之间的调用有相似之处，因此栈可以用来记录函数的调用过程。

首先引入1个概念——**栈帧(stack frame)**[\[3\]](#参考资料)。栈帧是指为1个函数调用单独分配的栈空间。当一个函数被调用时就要进入新的栈帧，调用者函数的栈帧称为调用者的帧，新的栈帧称为当前帧。被调用的函数运行结束后当前帧被弹出，返回到调用者的帧。

函数的调用一般包含参数，除此之外还需要记录调用者调用函数时执行到的位置。所有这些信息都记录在栈中，操作栈的是寄存器和汇编指令。

其中最重要的是寄存器ebp和esp，esp在空间扩展后会减小（因为栈是从高地址向低地址生长的），ebp始终指向当前帧的底部。

当程序初始化一个局部变量时，esp减小，向下开辟空间将数据移入，之后访问这些数据通过`ebp+偏移量`实现。

当程序调用函数时，则执行以下步骤[\[2\]](#参考资料)：

- 将实参**从右往左**地压入栈中
- 将下一条语句的地址压入栈中
- 将当前ebp压入栈中

当被调用的函数执行完成后，esp将指向ebp，然后弹出保存的调用者ebp到ebp寄存器，接着弹出返回地址到eip使进程继续执行调用者的代码。

调用栈的示意图如下图所示[\[4\]](#参考资料)（调用栈的图不同博客文章说法不一，有待研究书籍再确定）。

```
             栈底
+===========================+ -------------------
|            ...            |          ^
+---------------------------|       较早的帧
|            ...            |          v
+===========================+ -------------------
| param #n-1                |          ^         
+---------------------------+          |
|            ...            |          |
+---------------------------+          |
| param #0                  | 调用者(caller)的帧
+---------------------------+          |
| return address            |          |       
+---------------------------+          |
| saved %ebp                |          v
+===========================+ ------------------- %ebp
| local variables           | 被调用者(callee)的帧         v
+===========================+ <------------------ %esp
             栈顶
```

## 栈溢出的危害

若程序未检查输入的长度，由于输入是存储在栈中的局部变量区，且输入从低地址向高地址保存，则过长的输入可能覆盖高地址内存单元的内容。这样攻击者便可**篡改只读变量**或**函数的返回地址来控制程序流程**。

# 参考资料
[\[1\] 维基百科 stack overflow][1]

[\[2\] 内存布局与栈溢出&堆溢出原理][2]

[\[3\] 函数调用栈][3]

[\[4\] 程序员必备高级技术之函数调用栈][4]

[1]: https://en.wikipedia.org/wiki/Stack_overflow
[2]: https://lzwgiter.github.io/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E6%A0%88%E6%BA%A2%E5%87%BA-%E5%A0%86%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86/
[3]: https://www.jianshu.com/p/ea9fc7d2393d
[4]: https://juejin.im/post/5d1d465051882579df4a4745