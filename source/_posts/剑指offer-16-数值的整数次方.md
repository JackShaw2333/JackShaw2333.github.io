---
title: 剑指offer 16. 数值的整数次方
date: 2020-08-04 09:43:21
tags:
---

# 题目

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

<!--more--> 

示例 1:
```
输入: 2.00000, 10
输出: 1024.00000
```

示例 2:
```
输入: 2.10000, 3
输出: 9.26100
```

示例 3:
```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```
 

说明:

- `-100.0 < x < 100.0`
- n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

难度：中等

标签：递归

# 我的解答

求整数次幂的问题，比单纯连续乘更好的方法是快速幂。

快速幂利用了计算机二进制的性质，将原本时间复杂度为`O(n)`的连乘方法改进为`O(lgn)`。

```java
// Java
class Solution {
    public double myPow(double x, int n) {
        double ans = 1.0;
        if (n < 0) {
            x = 1 / x;
            ans = x;
            n = 0 - (n + 1);
        }

        while (n > 0) {
            if ((n & 1) == 1) {
                ans *= x;
            }
            x *= x;
            n >>= 1;
        }

        return ans;
    }
}
```

在指数为负数时，需要进行对底数取一次倒数并将指数取相反数，在取相反数的过程中需要注意的是定长补码所能表示的正负数范围不对称，即该数据类型所能表示的最小负数`TMin`在进行取反加一之后仍然是它本身。为避免这个问题，我们在处理时先让保存最终结果的变量`ans`乘一次底数，这样为负的指数的值就一定大于`TMin`，这样再进行取反就不会产生问题。