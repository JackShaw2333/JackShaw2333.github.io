---
title: AVL树
date: 2020-08-04 20:39:48
tags:
---

# AVL树

> 在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logn)。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。
> 
> 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。
> 
> ——[维基百科](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)

<!--more-->

## AVL树的定义

AVL树是带有平衡条件的二叉查找树，其每个节点的左子树和右子树的高度最多差1（空树的高度定义为-1）。

## AVL树的最少节点数

根据AVL树的定义，我们可以得出，设`S(h)`表示高度为h的AVL树中最少的节点数，那么`S(h) = S(h-1) + S(h-2) + 1`。公式中`S(h-1)`和`S(h-2)`表示左右子树的最少节点数，最后的1表示树根。其中`S(0) = 1`，`S(1) = 2`。

## AVL树的操作

除可能的插入操作外，所有的树操作都可以以`O(logn)`的时间进行。

### 插入

进行插入操作时需要更新通向根节点路径上的那些节点的平衡信息，而且更值得注意的是，插入操作可能导致AVL树的平衡性被破坏，因此我们需要对树进行简单的修正，这种修正被称为`旋转（rotation）`。

首先需要注意，在插入以后，只有那些从插入点到根节点的路径上的节点的平衡可能被改变。我们需要沿着这条路径上行到根并更新平衡信息，同时寻找需要重新平衡的节点，我们称之为`a`。

由于节点最多有2个儿子，因此不平衡时，`a`的左右两颗子树的高度相差2。简单分析可以得出，这种不平衡可能出现在以下4种情况中的1种：
1. 对`a`的**左**儿子的**左**子树进行了一次插入
2. 对`a`的**左**儿子的**右**子树进行了一次插入
3. 对`a`的**右**儿子的**左**子树进行了一次插入
4. 对`a`的**右**儿子的**右**子树进行了一次插入

其中情况1和情况4镜像对称，情况2和情况3镜像对称，因此理论上讨论有2种情况，实际编程时考虑4种情况。

- 第1种情况是插入发生在“外边”，即“左——左”或“右——右”。该种情况通过对树进行一次`单旋转`实现调整。
- 第2种情况是插入发生在“内部”，即“左——右”或“右——左”。该种情况通过对树进行一次`双旋转`实现调整。

### 单旋转

```
    k2                      k2                     k1
   / \        插入         /  \      单旋转        /  \
  k1  z   ==========>    k1   z   =========>    x    k2
 /  \                   /  \                   /    /  \
x    y                 x    y                new   y    z
                      /
                    new                     
```

上图显示了情况1（左儿子——左子树）单旋转的操作过程。旋转后，`k1`的左子树仍是`k1`的左子树，`k2`的右子树仍是`k2`的右子树，改变的是`k1`和`k2`的相对位置关系以及`k1`右子树的位置。

值得注意的是，旋转后的AVL树高度与未插入前的高度相等，因此，`a`通向根节点的路径上的其他节点的高度不需要进一步修正。

### 双旋转

对于情况2和情况3，单旋转并不能有效解决。为此需要双旋转。

```
    k2                      k2   
   / \        插入         /  \    
  k1  z   ==========>    k1   z  
 /  \                   /  \     
x    y                 x    y    
                             \
                             new                     
```

在情况2和情况3时，我们假设子树`y`有1个根`k2`和2颗子树（暂时为空）。因此，我们可以把整棵树看作有4颗子树（`a`，`b`，`c`，`d`），并且由3个节点（`k1`，`k2`，`k3`）连接。如下图所示

```
    k3                      k3                     k3                    k2
   / \      插入后         /  \      双旋转        /  \                  /   \
  k1  d   ==========>    k1    d   ==========>   k2   d  --------->    k1   k3
 /  \     b或c不为空     /  \                   /  \                   / \   / \
a    k2                a    k2                k1   c                 a   b c   d
                           /  \              /  \
                          b    c            a    b    
```

造成不平衡的原因恰巧是由于插入操作导致子树`b`或`c`非空。为此，双旋转操作将`k2`作为新的根。上图显示了情况2（左儿子——右子树）双旋转的操作过程，`k1`和`k2`发生了一次单旋转，然后后`k2`和`k3`发生一次单旋转。旋转后，`k1`的左子树仍是`k1`的左子树，`k3`的右子树仍是`k3`的右子树，而3个节点之间的位置关系以及`k2`的左右子树的位置都发生了改变。

与单旋转后的情况类似，我们也把树的高度恢复到了插入之前的水平，因此这样的更新是完善的。

### 编程实现

在具体实现中，单/双旋转的左右情况需要分别实现，而且左双旋转由**先对左儿子右单旋转后对根节点左单旋转构成**，右双旋转同理。

# 参考文献

[1] 数据结构与算法分析——C语言描述
