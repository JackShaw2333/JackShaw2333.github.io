---
title: CSAPP笔记
date: 2020-01-04 20:02:49
categories: [books, CS]
tags:
- CSAPP
---


## 引言

CSAPP的相关学习笔记。

[书籍相关资料](https://csapp.cs.cmu.edu/)

[课程网站](https://www.cs.cmu.edu/~213)

[课程视频](https://www.bilibili.com/video/BV1iW411d7hd)

<!--more-->

## 书

### 第1章

[习题参考答案](https://dreamanddead.gitbooks.io/csapp-3e-solutions/)

### 第2章

如果把比特串看作位向量，则布尔代数的运算和集合的运算的对应关系如下表所示。
| 布尔运算 | 集合运算 |
|:---------|:---------|
| &        | 交       |
| \        | 并       |
| ^        | 对称差   |
| ~        | 补       |

## 视频课程

### Lecture 03 Bits, Bytes, and Integer

尽量少使用无符号数。

#### Machine Words

机器字长指处理器惯常处理的数据的位数，也是地址或指针的位长度。

64位机器实际提供了2^47个字节的内存空间，并非2^64。

字长实际由硬件和编译器共同决定，编译器可以选择编译32位的代码或64位的代码。

### Lecture 04 Floating Point

#### IEEE的浮点数表示

计算机采用`IEEE 754`标准对浮点数进行编码。

`IEEE 754`标准将浮点数分为3部分：

- 符号（sign）。`s = 1`是负数，反之是正数
- 尾数（significand）。`M`是一个二进制小数
- 阶码（exponent）。`E`的作用是对浮点数加权，权重是2的`E`次幂

浮点数的位表示因此被分为3个字段，分别对这些值进行编码：

- 1个单独的符号位`s`直接编码符号
- k位阶码字段`exp`编码阶码`E`
- n位小数字段`frac`编码尾数`M`，依赖于阶码字段的值是否为0

| 浮点格式   | s   | exp  | frac |
|------------|-----|------|------|
| 单精度32位 | 1位 | 8位  | 23位 |
| 双精度64位 | 1位 | 11位 | 52位 |

根据`exp`的值，被编码的值可分为3种不同的情况

##### 规格化的值

当`exp`的位模式不全为1或0时，属于这种情况。

此时阶码字段被解释为以**偏置（bias）形式表示的有符号整数**，即`E = e - Bias`，其中`e`为`exp`字段被解释为无符号数时的值，而`Bias`是一个与`exp`字段长度有关的固定值，等于`2^(k-1)-1`（单精度时是127，双精度是1023）

`frac`为小数字段，表示的是小数`f`。尾数值`M = 1 + f`。这种表示方式被称为**隐含的以1开头（implied leading 1）的表示**。

##### 非规格化的值

当阶码域全为0时，所表示的数是非规格化的数。在这种情况下，阶码值是`E = 1 - Bias`，尾数`M = f`，不包含隐含的开头1。

非规格化数有2个用途：

- 提供了一种表示0的方法。需要注意的是，这种表示方法会出现`+0`和`-0`。
- 表示那些非常接近0的数，这种属性称为**逐渐溢出（gradual overflow）**。

##### 特殊值

当阶码全为1时的数为特殊值。此时当小数域为0时表示无穷；若小数域非0表示`NaN (Not a Number)`

如果将所有固定位长可表示的浮点数标注在数轴上，可以发现的一个现象是——可表示的数并非均匀分布的，越靠近原点处越稠密。

值得注意的是**规格化浮点数**和**非规格化浮点数**这样的编码方式保证了浮点数的进位在编码上的体现是平滑的。

#### 舍入（rounding）

常用的舍入方式有4种：

- 向偶数舍入（IEEE 754默认使用的摄入方式）
- 向零舍入
- 向下舍入
- 向上舍入

在二进制数舍入时注意`halfway`值，即被舍掉部分为`100...`（1后面全是0）的值。当被舍掉部分大于`halfway`值，则进位；小于则不进位；等于时则需要向偶数舍入，即若进位后舍入的值为偶数则进位，否则不进位。

#### 浮点运算

当浮点数相乘时，符号位相与，阶码位相加，尾数位相乘。

相乘的结果可能需要进行如下修正：

- 如果`M >= 2`，`M`右移并且增加阶码位
- 如果阶码位溢出，则结果为无穷
- 对`M`进行舍入操作

浮点数的运算具备以下特征

- 满足交换律
- 不满足结合律
- 不满足分配律

### Lecture 13 Linking

#### 为何使用Linker

- 模块化
- 提高效率
  - 时间上，当某个源文件改变时，只需编译改变的文件
  - 空间上，executable files只需存储使用了的函数代码，如使用C标准库的函数

#### Linker做了什么

##### step1 符号解析（symbol resolution）

链接器将每个符号引用和符号定义联系起来。

##### step2 重定向（relocation）

- 将分离的代码和数据段合并
- 将各个`.o`文件中符号在可执行文件中的地址确定下来
- 更新这些符号的引用

#### 3种object files

- 可重定位文件，`.o`文件，不能单独执行，需要和其他可重定位文件链接成可执行文件
- 可执行文件，`.out`文件，可以单独被载入内存执行
- 共享目标文件，`.so`文件

3种目标文件都采用ELF文件格式

#### ELF文件

ELF文件格式如下图所示。

```text
+============================+
| ELF header                 |
|----------------------------|
| Segment header table       |
| (required for executables) |
|----------------------------|
| .text section              |
|----------------------------|
| .rodata section            |
|----------------------------|
| .data section              |
|----------------------------|
| .bss section               |
|============================|
| .symtabl section           |
|----------------------------|
| .rel.txt section           |
|----------------------------|
| .rel.data section          |
|----------------------------|
| .debug section             |
|----------------------------|
| Section header table       |
+============================+
```

#### 符号和符号表

每个可重定位目标模块`m`都有一个符号表，它包含了模块**定义和引用的符号的信息**。

在linker的上下文中，有3种不同的符号：

- `m`定义并能被其他模块引用的**全局符号**，对应于**非静态的C函数和全局变量**
- 其他模块定义，被`m`模块引用的全局符号，称为**外部符号**，对应于**在其他模块中定义的非静态C函数和全局变量**
- 只被`m`定义和引用的**局部符号**，对应于**带`static`属性的C函数和全局变量**

`.symtab`中的符号表不包含对应于本地非静态程序变量的符号，这些符号定义在运行时被**栈**管理。但带有`static`属性的本地过程变量不在栈中管理。若同一模块的2个函数各自定义了一个静态局部变量，则编译器向汇编器输出2个不同名字的局部链接器符号。

符号表是由汇编器构造的，使用编译器输出到`.s`文件中的符号。每个符号都被分配到目标文件的某个节（section）

有3个特殊的伪节（pseudosection）在节头表中没有条目：

- `ABS`不该被重定位的符号
- `UNDEF`未定义的符号
- `COMMON`还未被分配位置的未初始化的数据目标

只有可重定位文件才有这些伪节。

`COMMON`和`.bss`的区别很细微，现代GCC根据下列规则分配符号：

- `COMMON`未初始化的全局变量
- `.bss`未初始化的静态变量以及初始化为0的全局或静态变量

#### 多重定义的全局符号

编译器向汇编器输出每个全局符号，或**强**或**弱**，汇编器把这个信息隐含编码在可重定位目标文件的符号表里。

- 函数和已初始化的全局变量是强符号
- 未初始化的全局变量是弱符号

根据强弱符号，linux链接器使用下列规则处理多重定义的符号：

- 不允许多个同名强符号
- 如果有1个强符号和若干弱符号同名，选择强符号
- 如果若干弱符号同名，随机选择1个符号

使用GCC`-fno-common`选项调用链接器，所有的重名都将会除非错误。`-Werror`选项将所有警告变为错误。

回到`COMMON`和`.bss`的符号分配问题，当编译器遇到一个弱全局符号时，它无法确定其他模块是否会有同名弱符号，为此它将该弱符号分配给`COMMON`，把决定权留给链接器。而被初始化为0的符号为强符号，编译器可以放心地将其分配到`.bss`。类似地，静态符号的构造也是唯一的，因此静态符号不会被分配到`COMMON`。

因为全局变量的种种规则以及可能造成的隐藏问题，尽量少使用全局变量。如果要使用

- 尽可能使用`static`进行限制
- 尽可能初始化
- 如果使用外部的全局变量，使用`extern`进行标识

#### 与静态库链接

至此，我们假设的情况都是链接器读取一组可重定位目标文件，并将它们链接起来形成可执行文件。

考察这样一个问题，我们编写的C程序经常需要使用标准库函数，如`atoi`，`printf`等，那么我们使用这些函数时应该如何链接呢？

一个自然的想法是，将同一文件中的标准库函数编译成一个可重定位文件，与程序员编写的可重定位链接成1个可执行文件。然而这个想法有很严重的缺点：

- 系统中每个使用了标准库函数的可执行文件都将包含所有标准库函数的完全副本，这对于硬盘空间是一大浪费，当许多这样的可执行文件被载入内存后，对于内存又是一大浪费
- 开发者对标准库文件进行任何修改后，都必须重新编译，费时费力

由此，还有另一个想法——将每个标准库函数单独编译为1个可重定位文件，按需链接。这一想法规避了第1个想法的2大缺点，但是又引入了新的问题——过多的标准库函数的可重定位文件需要编程人员显式链接，增加错误可能。

由此**静态库**的概念被提出。相关的函数可以被编译为独立的目标模块，然后封装成1个单独的静态库文件，链接时应用程序可以只显式指定静态库文件，真正的链接过程中，链接器将只复制被程序引用的目标模块，这样完美的解决了前面2个想法的问题。

在Linux系统中，静态库以一种称为**存档（archive）**的特殊文件格式存放在磁盘中。存档文件是一组链接起来的可重定位目标文件的集合，有一个头部描述每个成员文件的大小和位置，以后缀名`.a`标识。

静态库虽然好用，但由于链接器解析外部引用的算法特点，当定义一个符号的库出现在引用这个符号的目标文件之前，链接就会失败，因此关于静态库的使用准则是——将其放在命令行行尾。

如果静态库之间不是独立的话，还需对它们进行排序，使得对于每个被某一存档文件中某个成员引用的外部符号`s`，在命令行中至少有一个含有对`s`定义的文件是在这之后的。

如果需要满足依赖需求，可以在命令行上重复库。

#### 重定位（relocation）

一旦链接器完成了符号解析，就把代码中每个符号引用和一个符号定义关联起来，此时链接器就知道了输入模块中代码节和数据节的确切大小。接下来就可开始重定位。

重定位时将合并输入模块，并为每个符号分配运行时地址，如下图所示。

```text
relocatable object files

+=============+
| system code | .text
+-------------+
| system data | .data
+=============+

main.o
+=======================+
| main()                | .text
+-----------------------+
| int array[2] = {1, 2} | .data
+=======================+

sum.o
+=======+
| sum() | .text
+=======+

在链接后

executable object files

+=======================+
| Headers               |
+-----------------------+  ------
| system code           |  ^
|-----------------------|  |
| main()                |  |
|-----------------------|  .text
| sum()                 |  |
|-----------------------|  |
| more system code      |  v
+-----------------------+  ------
| system data           |  ^
|-----------------------|  .data
| int array[2] = {1, 2} |  v
+-----------------------+  ------
| .symtab               |
| .debug                |
+=======================+

```

重定位由2部分组成：

##### 重定位节和符号定义

这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后链接器将运行时内存地址赋给新的聚合节及每个符号。这一步完成后，程序中每条指令和全局变量都有唯一的运行时内存地址。

##### 重定位节中的符号引用

链接器修改代码节和数据节中对每个符号的引用，使之指向正确的运行时地址。为此链接器依赖于可重定位目标模块中称为**重定位条目**的数据结构

## 习题

[习题参考答案](https://www.cnblogs.com/machao/p/8397961.html)

### 2.12

> A. x &= 0x000000FF
> B. x ^= 0xFFFFFF00
> C. x |= 0x000000FF

总结：

1. 与。与1不变，与0为0
2. 或。或1为1，或0不变
3. 异或。异或1取反，异或0不变
4. 要求结果一部分不变，一部分变0——与。
5. 要求结果一部分不变，一部分变1——或。
6. 要求结果一部分不变，一部分取反——异或。

### 2.13

`bis`等价于`z |= m`；

`bic`等价于`z &= ~m`。

```cpp
bool_or: int result = bis(x, y);

bool_xor: int result = bis(bic(x,y), bix(y,x));
```

因为`x ^ y = (x & ~y) | (y & ~x)`

### 2.15

> ~(x ^ y)

### 2.25

当`length`为0时，`length-1`为`UMax`，导致`for`循环时数组越界。

应当将函数头部分改为

```c
float sum_elements(float a[], unsigned length)
```

### 2.26

A. 当字符串`s`的长度小于字符串`t`的长度时
B. 根据无符号数算术运算的规则，此时`strlen(s)-strlen(t)`的结果不是负数产生`下溢`。
C. 将`strlonger`函数改为：

```c
int strlonger(char *s, char *t)
{
    return (int)strlen(s) - (int)strlen(t) > 0;
}
```

### 2.30

```c
int tadd_ok(int x, int y)
{
    int sum = x + y;
    if (x>0 && y>0 && sum<0 || x<0 && y<0 && sum>0)
        return 0;
    else
        return 1;
}
```
